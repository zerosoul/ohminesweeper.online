diff --git a/node_modules/minesweeper-redux/.DS_Store b/node_modules/minesweeper-redux/.DS_Store
new file mode 100644
index 0000000..1ec6bba
Binary files /dev/null and b/node_modules/minesweeper-redux/.DS_Store differ
diff --git a/node_modules/minesweeper-redux/dist/.DS_Store b/node_modules/minesweeper-redux/dist/.DS_Store
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/minesweeper-redux/dist/__tests__/Minesweeper.test.d.ts b/node_modules/minesweeper-redux/dist/__tests__/Minesweeper.test.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/minesweeper-redux/dist/__tests__/Minesweeper.test.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/minesweeper-redux/dist/actions/actions.d.ts b/node_modules/minesweeper-redux/dist/actions/actions.d.ts
index d31d6b8..cc69034 100644
--- a/node_modules/minesweeper-redux/dist/actions/actions.d.ts
+++ b/node_modules/minesweeper-redux/dist/actions/actions.d.ts
@@ -1,15 +1,13 @@
-import { Difficulty, TimerCallback, Minesweeper, Coordinate } from '../core/types';
+import { Difficulty, Minesweeper, Coordinate } from '../core/types';
 export interface StartGameActionOptions {
     difficulty: Difficulty;
     randSeed: number;
-    timerCallback?: TimerCallback;
 }
 export interface StartGameAction extends StartGameActionOptions {
     type: 'START_GAME';
 }
 export interface LoadGameActionOptions {
     gameState: Minesweeper;
-    timerCallback?: TimerCallback;
 }
 export interface LoadGameAction extends LoadGameActionOptions {
     type: 'LOAD_GAME';
@@ -29,9 +27,6 @@ export interface ToggleFlagAction extends ToggleFlagActionOptions {
 export interface UndoLoosingMoveAction {
     type: 'UNDO_LOOSING_MOVE';
 }
-export interface TickTimerAction {
-    type: 'TICK_TIMER';
-}
 /** Create a minesweeper game. */
 export declare const startGame: (options: StartGameActionOptions) => StartGameAction;
 /** Load a game from given game state. */
@@ -42,6 +37,4 @@ export declare const revealCell: (options: RevealCellActionOptions) => RevealCel
 export declare const toggleFlag: (options: ToggleFlagActionOptions) => ToggleFlagAction;
 /** Load the previous state before the game was lost. */
 export declare const undoLoosingMove: () => UndoLoosingMoveAction;
-/** Tick the game timer. Add 1 (seconds) to elapsed time. */
-export declare const tickTimer: () => TickTimerAction;
-export declare type GameActions = StartGameAction | LoadGameAction | ToggleFlagAction | RevealCellAction | UndoLoosingMoveAction | TickTimerAction;
+export type GameActions = StartGameAction | LoadGameAction | ToggleFlagAction | RevealCellAction | UndoLoosingMoveAction;
diff --git a/node_modules/minesweeper-redux/dist/actions/types.d.ts b/node_modules/minesweeper-redux/dist/actions/types.d.ts
index f5dc157..6c9f21b 100644
--- a/node_modules/minesweeper-redux/dist/actions/types.d.ts
+++ b/node_modules/minesweeper-redux/dist/actions/types.d.ts
@@ -1 +1 @@
-export declare type GameType = 'START_GAME' | 'TOGGLE_FLAG' | 'REVEAL_CELL' | 'UNDO_LOOSING_MOVE' | 'TICK_TIMER' | 'LOAD_GAME';
+export type GameType = 'START_GAME' | 'TOGGLE_FLAG' | 'REVEAL_CELL' | 'UNDO_LOOSING_MOVE' | 'LOAD_GAME';
diff --git a/node_modules/minesweeper-redux/dist/core/game.d.ts b/node_modules/minesweeper-redux/dist/core/game.d.ts
index ffa5873..01f216b 100644
--- a/node_modules/minesweeper-redux/dist/core/game.d.ts
+++ b/node_modules/minesweeper-redux/dist/core/game.d.ts
@@ -1,13 +1,9 @@
-import { Difficulty, TimerCallback, Minesweeper, Coordinate } from './types';
+import { Difficulty, Minesweeper, Coordinate } from './types';
 /** Create a minesweeper game. */
-export declare function startGame(randSeed: number, difficulty: Difficulty, timerCallback?: TimerCallback): Minesweeper;
-/** Load a game state. */
-export declare function loadGame(game: Minesweeper, timerCallback?: TimerCallback): Minesweeper;
+export declare function startGame(randSeed: number, difficulty: Difficulty): Minesweeper;
 /** Make cell revealed at the given coordinate. */
 export declare function revealCell(game: Minesweeper, coordinate: Coordinate): Minesweeper;
 /** Toggle the flag value of cell at the given coordinate. */
 export declare function toggleFlag(game: Minesweeper, coordinate: Coordinate): Minesweeper;
-/** Increment elapsed time by 1. */
-export declare function tickTimer(game: Minesweeper): Minesweeper;
 /** Load the previous state before the game had been lost. */
 export declare function undoLoosingMove(game: Minesweeper): Minesweeper;
diff --git a/node_modules/minesweeper-redux/dist/core/grid.d.ts b/node_modules/minesweeper-redux/dist/core/grid.d.ts
index 193a69b..c866a47 100644
--- a/node_modules/minesweeper-redux/dist/core/grid.d.ts
+++ b/node_modules/minesweeper-redux/dist/core/grid.d.ts
@@ -7,6 +7,8 @@ export declare function revealCellInGrid(grid: Grid, atCoordinate: Coordinate):
 export declare function toggleFlagInGrid(grid: Grid, coordinate: Coordinate): Grid;
 /** Convert the grid to a win state. Reveals all cells. */
 export declare function revealAllCells(grid: Grid): Grid;
+/** Convert the grid to a win state. Flag all mine cells. */
+export declare function flagAllMineCells(grid: Grid): Grid;
 /** Fill the grid with mine and water cells. A seed coordinate is needed as the first cell
  * clicked should be a water cell with a mine count of 0. Returns new minesweeper grid instance.
  */
diff --git a/node_modules/minesweeper-redux/dist/core/types.d.ts b/node_modules/minesweeper-redux/dist/core/types.d.ts
index 802d651..2d45784 100644
--- a/node_modules/minesweeper-redux/dist/core/types.d.ts
+++ b/node_modules/minesweeper-redux/dist/core/types.d.ts
@@ -1,5 +1,5 @@
 /** Contains the necessary values for a minesweeper game. */
-export declare type Minesweeper = Readonly<{
+export type Minesweeper = Readonly<{
     /** The difficulty of the game. */
     difficulty: Difficulty;
     /** The current status of the game. */
@@ -16,40 +16,30 @@ export declare type Minesweeper = Readonly<{
     remainingFlags: number;
     /** The number to seed RandomNumberGenerator */
     randSeed: number;
-    /** The amount of time in ms since the game began.  */
-    elapsedTime: number;
-    /** Function that is called once every second. */
-    timerCallback?: TimerCallback;
-    /** Stops the timer. The property is set when timer has been started. */
-    timerStopper?: TimerStopper;
 }>;
 /** The status of a cell. */
-export declare type CellStatus = 'hidden' | 'flagged' | 'revealed' | 'detonated';
+export type CellStatus = 'hidden' | 'flagged' | 'revealed' | 'detonated';
 /** A cell of a minesweeper game. */
-export declare type Cell = Readonly<{
+export type Cell = Readonly<{
     /** The status of the cell. */
     status: CellStatus;
     /** The amount of adjacent mines surrounding the cell. Is `-1` if cell is a mine. */
     mineCount: number;
 }>;
 /** A coordinate of a grid. */
-export declare type Coordinate = Readonly<{
+export type Coordinate = Readonly<{
     x: number;
     y: number;
 }>;
 /** The minesweeper game's difficulty level. */
-export declare type Difficulty = Readonly<{
+export type Difficulty = Readonly<{
     height: number;
     width: number;
     numMines: number;
 }>;
 /** The current status of the game. */
-export declare type GameStatus = 'waiting' | 'ready' | 'running' | 'loss' | 'win';
-/** A callback for the game timer. */
-export declare type TimerCallback = () => void;
-/** Stops a timer. It is the function returned when timer is started. */
-export declare type TimerStopper = () => void;
+export type GameStatus = 'waiting' | 'ready' | 'running' | 'loss' | 'win';
 /** A grid made up of cells. */
-export declare type Grid = ReadonlyArray<ReadonlyArray<Cell>>;
+export type Grid = ReadonlyArray<ReadonlyArray<Cell>>;
 /** Generates a random number from a seed number. */
-export declare type RandomNumberGenerator = (max?: number, min?: number) => number;
+export type RandomNumberGenerator = (max?: number, min?: number) => number;
diff --git a/node_modules/minesweeper-redux/dist/minesweeper-redux.d.ts b/node_modules/minesweeper-redux/dist/minesweeper-redux.d.ts
new file mode 100644
index 0000000..df7053e
--- /dev/null
+++ b/node_modules/minesweeper-redux/dist/minesweeper-redux.d.ts
@@ -0,0 +1 @@
+export * from './index'
diff --git a/node_modules/minesweeper-redux/dist/minesweeper-redux.js b/node_modules/minesweeper-redux/dist/minesweeper-redux.js
index 03e4270..c7b925e 100644
--- a/node_modules/minesweeper-redux/dist/minesweeper-redux.js
+++ b/node_modules/minesweeper-redux/dist/minesweeper-redux.js
@@ -1,131 +1,125 @@
-const k = (e) => ({
+const I = (e) => ({
   type: "START_GAME",
   ...e
-}), V = (e) => ({
+}), N = (e) => ({
   type: "LOAD_GAME",
   ...e
-}), W = (e) => ({
+}), T = (e) => ({
   type: "REVEAL_CELL",
   ...e
-}), q = (e) => ({
+}), V = (e) => ({
   type: "TOGGLE_FLAG",
   ...e
-}), K = () => ({
+}), W = () => ({
   type: "UNDO_LOOSING_MOVE"
-}), U = () => ({
-  type: "TICK_TIMER"
-}), C = {
+}), p = {
   easy: { height: 9, width: 9, numMines: 10 },
   medium: { height: 16, width: 16, numMines: 40 },
   hard: { height: 30, width: 16, numMines: 99 }
-}, P = (e, t, n) => g(e, t, n) ? {
+}, q = (e, n, t) => g(e, n, t) ? {
   height: e,
-  width: t,
-  numMines: n
+  width: n,
+  numMines: t
 } : (console.warn(
-  `height, width, and numMines must be positive whole numbers, height: ${e}, width: ${t}, numMines: ${n}. Defaulting to easy config.`
-), C.easy), X = (e, t) => g(e, t) ? { x: e, y: t } : (console.warn(`x and y must be positive whole numbers, x: ${e} y: ${t}. Defaulting to 0, 0.`), { x: 0, y: 0 }), Y = (e) => ({
-  ...e,
-  timerCallback: void 0,
-  timerStopper: void 0
-}), z = (e, t) => v(e.grid, t), H = (e) => e.status === "running", J = (e) => e.status === "loss", Q = (e) => e.status === "loss" || e.status === "win", Z = (e) => e.grid.map(
-  (t) => t.filter((n) => n.status === "revealed" || n.status === "detonated").length
-).reduce((t, n) => t + n), g = (...e) => !e.some((t) => !(t >= 0 && t % 1 === 0));
-function v(e, t) {
-  const n = () => "---".repeat(e[0].length || 0) + `
-`, s = (i) => {
-    if (t)
-      return i.mineCount === -1 ? "ðŸ’£" : `${i.mineCount}`;
-    switch (i.status) {
+  `height, width, and numMines must be positive whole numbers, height: ${e}, width: ${n}, numMines: ${t}. Defaulting to easy config.`
+), p.easy), U = (e, n) => g(e, n) ? { x: e, y: n } : (console.warn(`x and y must be positive whole numbers, x: ${e} y: ${n}. Defaulting to 0, 0.`), { x: 0, y: 0 }), P = (e, n) => C(e.grid, n), X = (e) => e.status === "running", Y = (e) => e.status === "loss", k = (e) => e.status === "loss" || e.status === "win", z = (e) => e.grid.map(
+  (n) => n.filter((t) => t.status === "revealed" || t.status === "detonated").length
+).reduce((n, t) => n + t), g = (...e) => !e.some((n) => !(n >= 0 && n % 1 === 0));
+function C(e, n) {
+  const t = () => "---".repeat(e[0].length || 0) + `
+`, r = (a) => {
+    if (n)
+      return a.mineCount === -1 ? "ðŸ’£" : `${a.mineCount}`;
+    switch (a.status) {
       case "hidden":
         return "#";
       case "flagged":
         return "ðŸš©";
       case "revealed":
-        return i.mineCount === -1 ? "ðŸ’£" : i.mineCount > 0 ? `${i.mineCount}` : "ðŸŒŠ";
+        return a.mineCount === -1 ? "ðŸ’£" : a.mineCount > 0 ? `${a.mineCount}` : "ðŸŒŠ";
       case "detonated":
         return "ðŸ’¥";
     }
-  }, r = (i) => "|" + i.map((o, l) => {
-    const d = s(o);
+  }, s = (a) => "|" + a.map((o, l) => {
+    const d = r(o);
     return l === 0 ? `${d}` : `, ${d}`;
   }).join("") + `|
-`, a = e.map((i) => r(i)).join("");
-  return n() + a + n();
+`, i = e.map((a) => s(a)).join("");
+  return t() + i + t();
 }
 function G(e) {
   e === 0 && console.warn("seed cannot be 0, defaulting to 1");
-  let t = e || 1;
-  return (n = 1, s = 0) => {
-    t = (t * 9301 + 49297) % 233280;
-    const r = t / 233280;
-    return s + r * (n - s);
+  let n = e || 1;
+  return (t = 1, r = 0) => {
+    n = (n * 9301 + 49297) % 233280;
+    const s = n / 233280;
+    return r + s * (t - r);
   };
 }
-const f = [-1, 0, 1].flatMap((e) => [-1, 0, 1].map((t) => ({ x: t, y: e }))).filter(({ x: e, y: t }) => !(e === 0 && t === 0));
-function S(e, t) {
-  return Array(e).fill(Array(t).fill(void 0)).map(
-    (n) => n.map(() => ({
+const m = [-1, 0, 1].flatMap((e) => [-1, 0, 1].map((n) => ({ x: n, y: e }))).filter(({ x: e, y: n }) => !(e === 0 && n === 0));
+function y(e, n) {
+  return Array(e).fill(Array(n).fill(void 0)).map(
+    (t) => t.map(() => ({
       status: "hidden",
       mineCount: 0
     }))
   );
 }
-function p(e, t) {
-  const n = e.map(
-    (a, i) => a.map(
-      (u, o) => i === t.y && o === t.x ? { ...u, status: "revealed" } : u
+function f(e, n) {
+  const t = e.map(
+    (i, a) => i.map(
+      (u, o) => a === n.y && o === n.x ? { ...u, status: "revealed" } : u
     )
   );
-  if (n[t.y][t.x].mineCount !== 0)
-    return n;
-  const r = $(n, t);
-  return n.map(
-    (a) => a.map((i) => r.includes(i) ? { ...i, status: "revealed" } : i)
+  if (t[n.y][n.x].mineCount !== 0)
+    return t;
+  const s = $(t, n);
+  return t.map(
+    (i) => i.map((a) => s.includes(a) ? { ...a, status: "revealed" } : a)
   );
 }
-function y(e, t) {
-  const n = e[t.y][t.x];
-  return n.status !== "hidden" && n.status !== "flagged" ? e : e.map(
-    (s, r) => s.map(
-      (a, i) => r === t.y && i === t.x ? {
-        ...a,
-        status: a.status === "flagged" ? "hidden" : "flagged"
-      } : a
+function M(e, n) {
+  const t = e[n.y][n.x];
+  return t.status !== "hidden" && t.status !== "flagged" ? e : e.map(
+    (r, s) => r.map(
+      (i, a) => s === n.y && a === n.x ? {
+        ...i,
+        status: i.status === "flagged" ? "hidden" : "flagged"
+      } : i
     )
   );
 }
-function M(e) {
+function v(e) {
   return e.map(
-    (t) => t.map((n) => n.status !== "revealed" ? { ...n, status: "revealed" } : n)
+    (n) => n.map((t) => t.mineCount == -1 ? { ...t, status: "flagged" } : t)
   );
 }
-function w(e, t, n, s) {
-  const r = b(
-    n,
-    t.height,
-    t.width,
-    t.numMines,
-    s
-  ), a = (o) => r.some((l) => c(l, o)) ? { status: "hidden", mineCount: -1 } : {
+function w(e, n, t, r) {
+  const s = E(
+    t,
+    n.height,
+    n.width,
+    n.numMines,
+    r
+  ), i = (o) => s.some((l) => c(l, o)) ? { status: "hidden", mineCount: -1 } : {
     status: "hidden",
-    mineCount: T(r, o)
-  }, i = e.map((o, l) => o.map((d, h) => a({ x: h, y: l }))), u = i[n.y][n.x];
-  return u.mineCount === -1 && console.warn("cell should not be a mine cell", u, n), p(i, n);
+    mineCount: A(s, o)
+  }, a = e.map((o, l) => o.map((d, h) => i({ x: h, y: l }))), u = a[t.y][t.x];
+  return u.mineCount === -1 && console.warn("cell should not be a mine cell", u, t), f(a, t);
 }
-function x(e, t) {
+function x(e, n) {
   return e.map(
-    (n, s) => n.map(
-      (r, a) => s === t.y && a === t.x ? { ...r, status: "detonated" } : r.status === "revealed" ? r : { ...r, status: "revealed" }
+    (t, r) => t.map(
+      (s, i) => r === n.y && i === n.x ? { ...s, status: "detonated" } : s.mineCount === -1 ? { ...s, status: "revealed" } : s
     )
   );
 }
-function L(e) {
-  const { revealedWaterCells: t, mines: n, totalCells: s } = e.flatMap((r) => r).reduce(
-    (r, a) => ({
-      revealedWaterCells: a.status === "revealed" && a.mineCount !== -1 ? r.revealedWaterCells + 1 : r.revealedWaterCells,
-      mines: a.mineCount === -1 ? r.mines + 1 : r.mines,
-      totalCells: r.totalCells + 1
+function S(e) {
+  const { revealedWaterCells: n, mines: t, totalCells: r } = e.flatMap((s) => s).reduce(
+    (s, i) => ({
+      revealedWaterCells: i.status === "revealed" && i.mineCount !== -1 ? s.revealedWaterCells + 1 : s.revealedWaterCells,
+      mines: i.mineCount === -1 ? s.mines + 1 : s.mines,
+      totalCells: s.totalCells + 1
     }),
     {
       revealedWaterCells: 0,
@@ -133,191 +127,160 @@ function L(e) {
       totalCells: 0
     }
   );
-  return t === s - n;
+  return n === r - t;
 }
-function E(e) {
-  const { flagged: t, mines: n } = e.flatMap((s) => s).reduce(
-    (s, r) => ({
-      flagged: r.status === "flagged" ? s.flagged + 1 : s.flagged,
-      mines: r.mineCount === -1 ? s.mines + 1 : s.mines
+function L(e) {
+  const { flagged: n, mines: t } = e.flatMap((r) => r).reduce(
+    (r, s) => ({
+      flagged: s.status === "flagged" ? r.flagged + 1 : r.flagged,
+      mines: s.mineCount === -1 ? r.mines + 1 : r.mines
     }),
     { flagged: 0, mines: 0 }
   );
-  return { numFlagged: t, remainingFlags: n - t };
+  return { numFlagged: n, remainingFlags: t - n };
 }
-function T(e, t) {
-  return f.filter(({ x: n, y: s }) => {
-    const r = { x: t.x + n, y: t.y + s };
-    return r.x >= 0 && r.y >= 0 && e.some((a) => c(a, r));
+function A(e, n) {
+  return m.filter(({ x: t, y: r }) => {
+    const s = { x: n.x + t, y: n.y + r };
+    return s.x >= 0 && s.y >= 0 && e.some((i) => c(i, s));
   }).length;
 }
-function c(e, t) {
-  return e.y === t.y && e.x === t.x;
+function c(e, n) {
+  return e.y === n.y && e.x === n.x;
 }
-function b(e, t, n, s, r) {
-  const a = G(r), i = () => {
+function E(e, n, t, r, s) {
+  const i = G(s), a = () => {
     const o = {
-      x: Math.floor(a() * n),
-      y: Math.floor(a() * t)
+      x: Math.floor(i() * t),
+      y: Math.floor(i() * n)
     };
-    return A(e, o) < 2 ? i() : o;
+    return F(e, o) < 2 ? a() : o;
   }, u = [];
-  for (; u.length !== s; ) {
-    const o = i();
+  for (; u.length !== r; ) {
+    const o = a();
     u.filter((d) => c(d, o)).length === 0 && u.push(o);
   }
   return u;
 }
-function A(e, t) {
-  const n = Math.abs(t.x - e.x), s = Math.abs(t.y - e.y), r = Math.min(n, s), a = Math.max(n, s), i = r, u = a - r;
-  return Math.sqrt(2) * i + u;
+function F(e, n) {
+  const t = Math.abs(n.x - e.x), r = Math.abs(n.y - e.y), s = Math.min(t, r), i = Math.max(t, r), a = s, u = i - s;
+  return Math.sqrt(2) * a + u;
 }
-function $(e, t) {
-  const n = [], s = (r) => {
-    f.forEach(({ x: a, y: i }) => {
+function $(e, n) {
+  const t = [], r = (s) => {
+    m.forEach(({ x: i, y: a }) => {
       const u = {
-        x: r.x + a,
-        y: r.y + i
+        x: s.x + i,
+        y: s.y + a
       };
       if (u.y < 0 || u.x < 0 || u.y >= e.length || u.x >= e[0].length)
         return;
       const o = e[u.y][u.x];
-      o.status !== "hidden" || n.includes(o) || (n.push(o), o.mineCount === 0 && s(u));
+      o.status !== "hidden" || t.includes(o) || (t.push(o), o.mineCount === 0 && r(u));
     });
   };
-  return s(t), n;
+  return r(n), t;
 }
-function F(e, t, n) {
+function b(e, n) {
   return {
-    difficulty: t,
-    numCells: t.height * t.width,
-    grid: S(t.height, t.width),
+    difficulty: n,
+    numCells: n.height * n.width,
+    grid: y(n.height, n.width),
     status: "ready",
-    remainingFlags: t.numMines,
+    remainingFlags: n.numMines,
     randSeed: e,
-    timerCallback: n,
-    numFlagged: 0,
-    elapsedTime: 0
-  };
-}
-function _(e, t) {
-  return {
-    ...e,
-    timerCallback: t,
-    timerStopper: e.status === "running" ? m(t) : void 0
+    numFlagged: 0
   };
 }
-function I(e, t) {
+function _(e, n) {
   if (e.status === "ready")
     return {
       ...e,
-      grid: w(e.grid, e.difficulty, t, e.randSeed),
-      status: "running",
-      timerStopper: m(e.timerCallback)
+      grid: w(e.grid, e.difficulty, n, e.randSeed),
+      status: "running"
     };
   if (e.status !== "running")
     return e;
-  const n = e.grid[t.y][t.x];
-  if (n.status === "revealed")
+  const t = e.grid[n.y][n.x];
+  if (t.status === "revealed")
     return e;
-  if (n.mineCount === -1)
-    return e.timerStopper && e.timerStopper(), {
+  if (t.mineCount === -1)
+    return {
       ...e,
-      grid: x(e.grid, t),
+      grid: x(e.grid, n),
       savedGridState: e.grid,
       status: "loss"
     };
-  const s = p(e.grid, t);
-  return L(s) ? (e.timerStopper && e.timerStopper(), {
+  const r = f(e.grid, n);
+  return S(r) ? {
     ...e,
-    grid: M(e.grid),
+    grid: v(r),
+    remainingFlags: 0,
     status: "win"
-  }) : { ...e, grid: s };
+  } : { ...e, grid: r };
 }
-function O(e, t) {
-  const n = e.grid[t.y][t.x];
-  return e.status !== "running" || n.status === "revealed" ? e : {
+function O(e, n) {
+  const t = e.grid[n.y][n.x];
+  return e.status !== "running" || t.status === "revealed" ? e : {
     ...e,
-    grid: y(e.grid, t)
-  };
-}
-function R(e) {
-  return {
-    ...e,
-    elapsedTime: e.elapsedTime + 1
+    grid: M(e.grid, n)
   };
 }
 function D(e) {
   return e.status !== "loss" || !e.savedGridState ? (console.warn(`incorrect state of GameStatus: ${e.status}, GameStatus must be loss`), e) : {
     ...e,
-    timerStopper: m(e.timerCallback),
-    grid: e.savedGridState.map((t) => t.map((n) => n)),
+    grid: e.savedGridState.map((n) => n.map((t) => t)),
     status: "running"
   };
 }
-function m(e) {
-  if (!e)
-    return;
-  const t = setInterval(() => {
-    e();
-  }, 1e3);
-  return () => {
-    clearInterval(t);
-  };
-}
-const j = {
+const R = {
   difficulty: { height: 0, width: 0, numMines: 0 },
   numCells: 0,
   grid: [[]],
   numFlagged: 0,
   status: "waiting",
   remainingFlags: 0,
-  elapsedTime: 0,
   randSeed: 1
-}, N = (e, t) => {
-  switch (t.type) {
+}, j = (e, n) => {
+  switch (n.type) {
     case "START_GAME":
-      return F(t.randSeed, t.difficulty, t.timerCallback);
+      return b(n.randSeed, n.difficulty);
     case "LOAD_GAME":
-      return _(t.gameState, t.timerCallback);
+      return n.gameState;
     case "REVEAL_CELL":
-      return I(e, t.coordinate);
+      return _(e, n.coordinate);
     case "TOGGLE_FLAG":
-      return O(e, t.coordinate);
-    case "TICK_TIMER":
-      return R(e);
+      return O(e, n.coordinate);
     case "UNDO_LOOSING_MOVE":
       return D(e);
     default:
       return e;
   }
-}, B = (e = j, t) => {
-  const n = N(e, t);
-  if (n.grid !== e.grid) {
-    const { numFlagged: s, remainingFlags: r } = E(n.grid);
+}, H = (e = R, n) => {
+  const t = j(e, n);
+  if (t.grid !== e.grid) {
+    const { numFlagged: r, remainingFlags: s } = L(t.grid);
     return {
-      ...n,
-      remainingFlags: n.status === "win" || n.status === "loss" ? 0 : r,
-      numFlagged: s
+      ...t,
+      remainingFlags: t.status === "win" ? 0 : s,
+      numFlagged: r
     };
   }
-  return n;
+  return t;
 };
 export {
-  Z as countVisibleCells,
-  X as createCoordinate,
-  P as createDifficultyLevel,
-  C as difficulties,
-  B as gameReducer,
-  Y as getLoadableGameState,
-  z as getStringifiedGrid,
-  Q as isGameEnded,
-  J as isGameLost,
-  H as isGameRunning,
-  V as loadGame,
-  W as revealCell,
-  k as startGame,
-  U as tickTimer,
-  q as toggleFlag,
-  K as undoLoosingMove
+  z as countVisibleCells,
+  U as createCoordinate,
+  q as createDifficultyLevel,
+  p as difficulties,
+  H as gameReducer,
+  P as getStringifiedGrid,
+  k as isGameEnded,
+  Y as isGameLost,
+  X as isGameRunning,
+  N as loadGame,
+  T as revealCell,
+  I as startGame,
+  V as toggleFlag,
+  W as undoLoosingMove
 };
diff --git a/node_modules/minesweeper-redux/dist/minesweeper-redux.umd.cjs b/node_modules/minesweeper-redux/dist/minesweeper-redux.umd.cjs
index 8f79733..842d97c 100644
--- a/node_modules/minesweeper-redux/dist/minesweeper-redux.umd.cjs
+++ b/node_modules/minesweeper-redux/dist/minesweeper-redux.umd.cjs
@@ -1,3 +1,3 @@
-(function(u,c){typeof exports=="object"&&typeof module<"u"?c(exports):typeof define=="function"&&define.amd?define(["exports"],c):(u=typeof globalThis<"u"?globalThis:u||self,c(u["minesweeper-redux"]={}))})(this,function(u){"use strict";const c=e=>({type:"START_GAME",...e}),v=e=>({type:"LOAD_GAME",...e}),S=e=>({type:"REVEAL_CELL",...e}),y=e=>({type:"TOGGLE_FLAG",...e}),M=()=>({type:"UNDO_LOOSING_MOVE"}),w=()=>({type:"TICK_TIMER"}),h={easy:{height:9,width:9,numMines:10},medium:{height:16,width:16,numMines:40},hard:{height:30,width:16,numMines:99}},L=(e,t,n)=>p(e,t,n)?{height:e,width:t,numMines:n}:(console.warn(`height, width, and numMines must be positive whole numbers, height: ${e}, width: ${t}, numMines: ${n}. Defaulting to easy config.`),h.easy),b=(e,t)=>p(e,t)?{x:e,y:t}:(console.warn(`x and y must be positive whole numbers, x: ${e} y: ${t}. Defaulting to 0, 0.`),{x:0,y:0}),T=e=>({...e,timerCallback:void 0,timerStopper:void 0}),E=(e,t)=>x(e.grid,t),A=e=>e.status==="running",$=e=>e.status==="loss",F=e=>e.status==="loss"||e.status==="win",_=e=>e.grid.map(t=>t.filter(n=>n.status==="revealed"||n.status==="detonated").length).reduce((t,n)=>t+n),p=(...e)=>!e.some(t=>!(t>=0&&t%1===0));function x(e,t){const n=()=>"---".repeat(e[0].length||0)+`
-`,s=i=>{if(t)return i.mineCount===-1?"ðŸ’£":`${i.mineCount}`;switch(i.status){case"hidden":return"#";case"flagged":return"ðŸš©";case"revealed":return i.mineCount===-1?"ðŸ’£":i.mineCount>0?`${i.mineCount}`:"ðŸŒŠ";case"detonated":return"ðŸ’¥"}},r=i=>"|"+i.map((d,l)=>{const m=s(d);return l===0?`${m}`:`, ${m}`}).join("")+`|
-`,a=e.map(i=>r(i)).join("");return n()+a+n()}function R(e){e===0&&console.warn("seed cannot be 0, defaulting to 1");let t=e||1;return(n=1,s=0)=>{t=(t*9301+49297)%233280;const r=t/233280;return s+r*(n-s)}}const C=[-1,0,1].flatMap(e=>[-1,0,1].map(t=>({x:t,y:e}))).filter(({x:e,y:t})=>!(e===0&&t===0));function I(e,t){return Array(e).fill(Array(t).fill(void 0)).map(n=>n.map(()=>({status:"hidden",mineCount:0})))}function G(e,t){const n=e.map((a,i)=>a.map((o,d)=>i===t.y&&d===t.x?{...o,status:"revealed"}:o));if(n[t.y][t.x].mineCount!==0)return n;const r=P(n,t);return n.map(a=>a.map(i=>r.includes(i)?{...i,status:"revealed"}:i))}function O(e,t){const n=e[t.y][t.x];return n.status!=="hidden"&&n.status!=="flagged"?e:e.map((s,r)=>s.map((a,i)=>r===t.y&&i===t.x?{...a,status:a.status==="flagged"?"hidden":"flagged"}:a))}function j(e){return e.map(t=>t.map(n=>n.status!=="revealed"?{...n,status:"revealed"}:n))}function D(e,t,n,s){const r=q(n,t.height,t.width,t.numMines,s),a=d=>r.some(l=>f(l,d))?{status:"hidden",mineCount:-1}:{status:"hidden",mineCount:W(r,d)},i=e.map((d,l)=>d.map((m,ee)=>a({x:ee,y:l}))),o=i[n.y][n.x];return o.mineCount===-1&&console.warn("cell should not be a mine cell",o,n),G(i,n)}function N(e,t){return e.map((n,s)=>n.map((r,a)=>s===t.y&&a===t.x?{...r,status:"detonated"}:r.status==="revealed"?r:{...r,status:"revealed"}))}function V(e){const{revealedWaterCells:t,mines:n,totalCells:s}=e.flatMap(r=>r).reduce((r,a)=>({revealedWaterCells:a.status==="revealed"&&a.mineCount!==-1?r.revealedWaterCells+1:r.revealedWaterCells,mines:a.mineCount===-1?r.mines+1:r.mines,totalCells:r.totalCells+1}),{revealedWaterCells:0,mines:0,totalCells:0});return t===s-n}function k(e){const{flagged:t,mines:n}=e.flatMap(s=>s).reduce((s,r)=>({flagged:r.status==="flagged"?s.flagged+1:s.flagged,mines:r.mineCount===-1?s.mines+1:s.mines}),{flagged:0,mines:0});return{numFlagged:t,remainingFlags:n-t}}function W(e,t){return C.filter(({x:n,y:s})=>{const r={x:t.x+n,y:t.y+s};return r.x>=0&&r.y>=0&&e.some(a=>f(a,r))}).length}function f(e,t){return e.y===t.y&&e.x===t.x}function q(e,t,n,s,r){const a=R(r),i=()=>{const d={x:Math.floor(a()*n),y:Math.floor(a()*t)};return K(e,d)<2?i():d},o=[];for(;o.length!==s;){const d=i();o.filter(m=>f(m,d)).length===0&&o.push(d)}return o}function K(e,t){const n=Math.abs(t.x-e.x),s=Math.abs(t.y-e.y),r=Math.min(n,s),a=Math.max(n,s),i=r,o=a-r;return Math.sqrt(2)*i+o}function P(e,t){const n=[],s=r=>{C.forEach(({x:a,y:i})=>{const o={x:r.x+a,y:r.y+i};if(o.y<0||o.x<0||o.y>=e.length||o.x>=e[0].length)return;const d=e[o.y][o.x];d.status!=="hidden"||n.includes(d)||(n.push(d),d.mineCount===0&&s(o))})};return s(t),n}function U(e,t,n){return{difficulty:t,numCells:t.height*t.width,grid:I(t.height,t.width),status:"ready",remainingFlags:t.numMines,randSeed:e,timerCallback:n,numFlagged:0,elapsedTime:0}}function X(e,t){return{...e,timerCallback:t,timerStopper:e.status==="running"?g(t):void 0}}function Y(e,t){if(e.status==="ready")return{...e,grid:D(e.grid,e.difficulty,t,e.randSeed),status:"running",timerStopper:g(e.timerCallback)};if(e.status!=="running")return e;const n=e.grid[t.y][t.x];if(n.status==="revealed")return e;if(n.mineCount===-1)return e.timerStopper&&e.timerStopper(),{...e,grid:N(e.grid,t),savedGridState:e.grid,status:"loss"};const s=G(e.grid,t);return V(s)?(e.timerStopper&&e.timerStopper(),{...e,grid:j(e.grid),status:"win"}):{...e,grid:s}}function z(e,t){const n=e.grid[t.y][t.x];return e.status!=="running"||n.status==="revealed"?e:{...e,grid:O(e.grid,t)}}function H(e){return{...e,elapsedTime:e.elapsedTime+1}}function J(e){return e.status!=="loss"||!e.savedGridState?(console.warn(`incorrect state of GameStatus: ${e.status}, GameStatus must be loss`),e):{...e,timerStopper:g(e.timerCallback),grid:e.savedGridState.map(t=>t.map(n=>n)),status:"running"}}function g(e){if(!e)return;const t=setInterval(()=>{e()},1e3);return()=>{clearInterval(t)}}const Q={difficulty:{height:0,width:0,numMines:0},numCells:0,grid:[[]],numFlagged:0,status:"waiting",remainingFlags:0,elapsedTime:0,randSeed:1},Z=(e,t)=>{switch(t.type){case"START_GAME":return U(t.randSeed,t.difficulty,t.timerCallback);case"LOAD_GAME":return X(t.gameState,t.timerCallback);case"REVEAL_CELL":return Y(e,t.coordinate);case"TOGGLE_FLAG":return z(e,t.coordinate);case"TICK_TIMER":return H(e);case"UNDO_LOOSING_MOVE":return J(e);default:return e}},B=(e=Q,t)=>{const n=Z(e,t);if(n.grid!==e.grid){const{numFlagged:s,remainingFlags:r}=k(n.grid);return{...n,remainingFlags:n.status==="win"||n.status==="loss"?0:r,numFlagged:s}}return n};u.countVisibleCells=_,u.createCoordinate=b,u.createDifficultyLevel=L,u.difficulties=h,u.gameReducer=B,u.getLoadableGameState=T,u.getStringifiedGrid=E,u.isGameEnded=F,u.isGameLost=$,u.isGameRunning=A,u.loadGame=v,u.revealCell=S,u.startGame=c,u.tickTimer=w,u.toggleFlag=y,u.undoLoosingMove=M,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
+(function(d,c){typeof exports=="object"&&typeof module<"u"?c(exports):typeof define=="function"&&define.amd?define(["exports"],c):(d=typeof globalThis<"u"?globalThis:d||self,c(d["minesweeper-redux"]={}))})(this,function(d){"use strict";const c=e=>({type:"START_GAME",...e}),y=e=>({type:"LOAD_GAME",...e}),p=e=>({type:"REVEAL_CELL",...e}),v=e=>({type:"TOGGLE_FLAG",...e}),M=()=>({type:"UNDO_LOOSING_MOVE"}),f={easy:{height:9,width:9,numMines:10},medium:{height:16,width:16,numMines:40},hard:{height:30,width:16,numMines:99}},w=(e,n,t)=>h(e,n,t)?{height:e,width:n,numMines:t}:(console.warn(`height, width, and numMines must be positive whole numbers, height: ${e}, width: ${n}, numMines: ${t}. Defaulting to easy config.`),f.easy),S=(e,n)=>h(e,n)?{x:e,y:n}:(console.warn(`x and y must be positive whole numbers, x: ${e} y: ${n}. Defaulting to 0, 0.`),{x:0,y:0}),L=(e,n)=>x(e.grid,n),E=e=>e.status==="running",b=e=>e.status==="loss",A=e=>e.status==="loss"||e.status==="win",F=e=>e.grid.map(n=>n.filter(t=>t.status==="revealed"||t.status==="detonated").length).reduce((n,t)=>n+t),h=(...e)=>!e.some(n=>!(n>=0&&n%1===0));function x(e,n){const t=()=>"---".repeat(e[0].length||0)+`
+`,r=i=>{if(n)return i.mineCount===-1?"ðŸ’£":`${i.mineCount}`;switch(i.status){case"hidden":return"#";case"flagged":return"ðŸš©";case"revealed":return i.mineCount===-1?"ðŸ’£":i.mineCount>0?`${i.mineCount}`:"ðŸŒŠ";case"detonated":return"ðŸ’¥"}},s=i=>"|"+i.map((o,l)=>{const g=r(o);return l===0?`${g}`:`, ${g}`}).join("")+`|
+`,a=e.map(i=>s(i)).join("");return t()+a+t()}function $(e){e===0&&console.warn("seed cannot be 0, defaulting to 1");let n=e||1;return(t=1,r=0)=>{n=(n*9301+49297)%233280;const s=n/233280;return r+s*(t-r)}}const C=[-1,0,1].flatMap(e=>[-1,0,1].map(n=>({x:n,y:e}))).filter(({x:e,y:n})=>!(e===0&&n===0));function O(e,n){return Array(e).fill(Array(n).fill(void 0)).map(t=>t.map(()=>({status:"hidden",mineCount:0})))}function G(e,n){const t=e.map((a,i)=>a.map((u,o)=>i===n.y&&o===n.x?{...u,status:"revealed"}:u));if(t[n.y][n.x].mineCount!==0)return t;const s=q(t,n);return t.map(a=>a.map(i=>s.includes(i)?{...i,status:"revealed"}:i))}function _(e,n){const t=e[n.y][n.x];return t.status!=="hidden"&&t.status!=="flagged"?e:e.map((r,s)=>r.map((a,i)=>s===n.y&&i===n.x?{...a,status:a.status==="flagged"?"hidden":"flagged"}:a))}function R(e){return e.map(n=>n.map(t=>t.mineCount==-1?{...t,status:"flagged"}:t))}function j(e,n,t,r){const s=V(t,n.height,n.width,n.numMines,r),a=o=>s.some(l=>m(l,o))?{status:"hidden",mineCount:-1}:{status:"hidden",mineCount:N(s,o)},i=e.map((o,l)=>o.map((g,J)=>a({x:J,y:l}))),u=i[t.y][t.x];return u.mineCount===-1&&console.warn("cell should not be a mine cell",u,t),G(i,t)}function D(e,n){return e.map((t,r)=>t.map((s,a)=>r===n.y&&a===n.x?{...s,status:"detonated"}:s.mineCount===-1?{...s,status:"revealed"}:s))}function T(e){const{revealedWaterCells:n,mines:t,totalCells:r}=e.flatMap(s=>s).reduce((s,a)=>({revealedWaterCells:a.status==="revealed"&&a.mineCount!==-1?s.revealedWaterCells+1:s.revealedWaterCells,mines:a.mineCount===-1?s.mines+1:s.mines,totalCells:s.totalCells+1}),{revealedWaterCells:0,mines:0,totalCells:0});return n===r-t}function I(e){const{flagged:n,mines:t}=e.flatMap(r=>r).reduce((r,s)=>({flagged:s.status==="flagged"?r.flagged+1:r.flagged,mines:s.mineCount===-1?r.mines+1:r.mines}),{flagged:0,mines:0});return{numFlagged:n,remainingFlags:t-n}}function N(e,n){return C.filter(({x:t,y:r})=>{const s={x:n.x+t,y:n.y+r};return s.x>=0&&s.y>=0&&e.some(a=>m(a,s))}).length}function m(e,n){return e.y===n.y&&e.x===n.x}function V(e,n,t,r,s){const a=$(s),i=()=>{const o={x:Math.floor(a()*t),y:Math.floor(a()*n)};return W(e,o)<2?i():o},u=[];for(;u.length!==r;){const o=i();u.filter(g=>m(g,o)).length===0&&u.push(o)}return u}function W(e,n){const t=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=Math.min(t,r),a=Math.max(t,r),i=s,u=a-s;return Math.sqrt(2)*i+u}function q(e,n){const t=[],r=s=>{C.forEach(({x:a,y:i})=>{const u={x:s.x+a,y:s.y+i};if(u.y<0||u.x<0||u.y>=e.length||u.x>=e[0].length)return;const o=e[u.y][u.x];o.status!=="hidden"||t.includes(o)||(t.push(o),o.mineCount===0&&r(u))})};return r(n),t}function P(e,n){return{difficulty:n,numCells:n.height*n.width,grid:O(n.height,n.width),status:"ready",remainingFlags:n.numMines,randSeed:e,numFlagged:0}}function U(e,n){if(e.status==="ready")return{...e,grid:j(e.grid,e.difficulty,n,e.randSeed),status:"running"};if(e.status!=="running")return e;const t=e.grid[n.y][n.x];if(t.status==="revealed")return e;if(t.mineCount===-1)return{...e,grid:D(e.grid,n),savedGridState:e.grid,status:"loss"};const r=G(e.grid,n);return T(r)?{...e,grid:R(r),remainingFlags:0,status:"win"}:{...e,grid:r}}function X(e,n){const t=e.grid[n.y][n.x];return e.status!=="running"||t.status==="revealed"?e:{...e,grid:_(e.grid,n)}}function Y(e){return e.status!=="loss"||!e.savedGridState?(console.warn(`incorrect state of GameStatus: ${e.status}, GameStatus must be loss`),e):{...e,grid:e.savedGridState.map(n=>n.map(t=>t)),status:"running"}}const k={difficulty:{height:0,width:0,numMines:0},numCells:0,grid:[[]],numFlagged:0,status:"waiting",remainingFlags:0,randSeed:1},z=(e,n)=>{switch(n.type){case"START_GAME":return P(n.randSeed,n.difficulty);case"LOAD_GAME":return n.gameState;case"REVEAL_CELL":return U(e,n.coordinate);case"TOGGLE_FLAG":return X(e,n.coordinate);case"UNDO_LOOSING_MOVE":return Y(e);default:return e}},H=(e=k,n)=>{const t=z(e,n);if(t.grid!==e.grid){const{numFlagged:r,remainingFlags:s}=I(t.grid);return{...t,remainingFlags:t.status==="win"?0:s,numFlagged:r}}return t};d.countVisibleCells=F,d.createCoordinate=S,d.createDifficultyLevel=w,d.difficulties=f,d.gameReducer=H,d.getStringifiedGrid=L,d.isGameEnded=A,d.isGameLost=b,d.isGameRunning=E,d.loadGame=y,d.revealCell=p,d.startGame=c,d.toggleFlag=v,d.undoLoosingMove=M,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
diff --git a/node_modules/minesweeper-redux/dist/reducers/gameReducer.d.ts b/node_modules/minesweeper-redux/dist/reducers/gameReducer.d.ts
index c9fa767..946de9b 100644
--- a/node_modules/minesweeper-redux/dist/reducers/gameReducer.d.ts
+++ b/node_modules/minesweeper-redux/dist/reducers/gameReducer.d.ts
@@ -13,7 +13,4 @@ export declare const gameReducer: (state: Readonly<{
     numFlagged: number;
     remainingFlags: number;
     randSeed: number;
-    elapsedTime: number;
-    timerCallback?: import("..").TimerCallback | undefined;
-    timerStopper?: import("..").TimerStopper | undefined;
 }> | undefined, action: GameActions) => Minesweeper;
diff --git a/node_modules/minesweeper-redux/dist/util/util.d.ts b/node_modules/minesweeper-redux/dist/util/util.d.ts
index e0304cf..9d98c1f 100644
--- a/node_modules/minesweeper-redux/dist/util/util.d.ts
+++ b/node_modules/minesweeper-redux/dist/util/util.d.ts
@@ -7,8 +7,6 @@ export declare const difficulties: {
 export declare const createDifficultyLevel: (height: number, width: number, numMines: number) => Difficulty;
 /** Create a coordinate. */
 export declare const createCoordinate: (x: number, y: number) => Coordinate;
-/** Get game state that is loadable. */
-export declare const getLoadableGameState: (game: Minesweeper) => Minesweeper;
 /** Create a string representation of the grid. */
 export declare const getStringifiedGrid: (game: Minesweeper, showAllCells: boolean) => string;
 /** Check if the game is running. */
diff --git a/node_modules/minesweeper-redux/package.json b/node_modules/minesweeper-redux/package.json
index 0b19930..8fa2e27 100644
--- a/node_modules/minesweeper-redux/package.json
+++ b/node_modules/minesweeper-redux/package.json
@@ -5,11 +5,16 @@
   "type": "module",
   "main": "./dist/minesweeper-redux.umd.cjs",
   "module": "./dist/minesweeper-redux.js",
-  "types": "./dist/index.d.ts",
   "exports": {
     ".": {
-      "import": "./dist/minesweeper-redux.js",
-      "require": "./dist/minesweeper-redux.umd.cjs"
+      "import": {
+        "types": "./dist/index.d.ts",
+        "default": "./dist/minesweeper-redux.js"
+      },
+      "require": {
+        "types": "./dist/index.d.ts",
+        "default": "./dist/minesweeper-redux.umd.cjs"
+      }
     }
   },
   "files": [
